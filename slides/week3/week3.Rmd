---
title: "MFE R Programming Workshop"
author: "Brett Dunn"
date: "Fall 2016"
output:
  beamer_presentation:
    includes:
      in_header: ../slide_header.tex
    keep_tex: false
subtitle: Week 3
slide_level: 2
---

```{r, include=FALSE, echo=FALSE}
#opts_knit$set(progress = TRUE, verbose = TRUE, size="scriptsize")
options(dplyr.print_max=8, dplyr.width=60)
```

# Data Munging

## Hadley Wickham
 
- [Hadley Wickham](http://had.co.nz) is practically famous in the R world
- He's developed a ridiculous number of useful packages
    - e.g. `ggplot2`
- Today we will look at `dplyr` and `tidyr`


# `dplyr`

## `dplyr` intro
 
- `dplyr` is a package for data manipulation
- `data.table` is another fantastic package of this type
- I'll post a solution to today's lab using both
- These slides are a cut down version of the [dplyr introduction vignette ](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)


## Data: nycflights13
 
- To explore the basic data manipulation verbs of dplyr, we'll start
with the built in `nycflights13} data frame
- This dataset contains all flights that departed from New York City
in 2013
```{r, include=TRUE, echo=TRUE, results='hide', message=FALSE}
library(dplyr)
library(nycflights13)
```
```{r}
head(flights,4)
```
- dplyr can work with data frames as is, but if you're dealing with
large data, it's worthwhile to convert them to a `tbl_df`




## Single table verbs
- Dplyr aims to provide a function for each basic verb of data manipulation:
    - `filter()` (and `slice()`)
    - `arrange()`
    - `select()` (and `rename()`)
    - `distinct()`
    - `mutate()` (and `transmute()`)
    - `summarise()`
    - `sample_n()` and `sample_frac()`



## Filter rows with `filter()`
 
- `filter()` allows you to select a subset of rows in a data frame.
- The first argument is the name of the data frame.
- The second and subsequent arguments are the expressions that filter
the data frame
- Select all flights on January 1st with:

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
filter(flights, month == 1, day == 1)
```

## Select rows by position
 
- To select rows by position, use `slice()`

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
slice(flights, 1:10)
```


## Arrange rows with `arrange()`
 
- `arrange()` works similarly to `filter()` except that instead of filtering or selecting rows, it reorders them

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
arrange(flights, year, month, day)
```

## Use `desc()` to order a column in descending order

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
arrange(flights, desc(arr_delay))
```

## Select columns with `select()`
 
- `select()} allows you to rapidly zoom in on a useful subset using operations that usually only work on numeric variable positions:

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
# Select columns by name
select(flights, year, month, day)
# Select all columns between year and day (inclusive)
select(flights, year:day)
# Select all columns except those from year to day (inclusive)
select(flights, -(year:day))
```


## You can rename variables with `rename()`

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
rename(flights, tail_num = tailnum)
```


## `Extract distinct (unique) rows`
 
- A common use of `select()} is to find the values of a set of variables.
- This is particularly useful in conjunction with the `distinct()` verb

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
distinct(select(flights, tailnum))
distinct(select(flights, origin, dest))
```


## Add new columns with `mutate()`
```{r, include=TRUE, echo=TRUE, size="scriptsize"}
mutate(flights,
  gain = arr_delay - dep_delay,
  speed = distance / air_time * 60)
```


## If you only want to keep the new variables, use `transmute()`
```{r, include=TRUE, echo=TRUE, size="scriptsize"}
transmute(flights,
  gain = arr_delay - dep_delay,
  gain_per_hour = gain / (air_time / 60)
)
```


## Summarise values with `summarise()`
 
- The last verb is `summarise()}. It collapses a data frame to asingle row:

```{r, include=TRUE, echo=TRUE, size="scriptsize"}
summarise(flights,
  delay = mean(dep_delay, na.rm = TRUE))
```


## Commonalities

- The syntax and function of all these verbs are very similar:
    - The first argument is a data frame.
    - The subsequent arguments describe what to do with the data frame.
    - The result is a new data frame
- Together these properties make it easy to chain together multiple
simple steps to achieve a complex result.



## Grouped operations
 
- These verbs are useful on their own, but they become really powerful when you apply them to groups of observations
- In dplyr, you do this by with the `group_by()` function
- It breaks down a dataset into specified groups of rows


## Grouped operations (cont.)

- Grouping affects the verbs as follows:
    - grouped `select()` is the same as ungrouped `select()`, except that grouping variables are always retained.
    - grouped `arrange()` orders first by the grouping variables
    - `mutate()` and `filter()` are most useful in conjunction with window functions (like `rank()`, or `min(x) =` x=). They are described in detail in `vignette("window-functions")`.
    - `sample_n()` and `sample_frac()` sample the specified number/fraction of rows in each group.
    - `slice()` extracts rows within each group.
    - `summarise()` is powerful and easy to understand, as described in more detail below.



## `group_by` Example
- For example, we could use these to find the number of planes and the number of flights that go to each possible destination:


```{r, include=TRUE, echo=TRUE, size="scriptsize"}
destinations <- group_by(flights, dest)
summarise(destinations,
  planes = n_distinct(tailnum),
  flights = n()
)
```

## Chaining
 
- The dplyr API is functional --- function calls don't have
side-effects.
- You must always save their results. \alert{UGLY}
- To get around this problem, dplyr provides the `%>%` operator
- `x %>% f(y)` turns into `f(x, y)`

```{r, include=TRUE, echo=TRUE, size="scriptsize", eval=TRUE, warning=FALSE}
flights %>%
    group_by(year, month, day) %>%
    select(arr_delay, dep_delay) %>%
    summarise(arr = mean(arr_delay, na.rm = TRUE),
              dep = mean(dep_delay, na.rm = TRUE)) %>%
    filter(arr > 30 | dep > 30)
```

## Multiple table verbs
- dplyr implements the four most useful SQL joins:
    - `inner_join(x, y)`: matching x + y
    - `left_join(x, y)`: all x + matching y
    - `semi_join(x, y)`: all x with match in y
    - `anti_join(x, y)`: all x without match in y

- And provides methods for:
    - `intersect(x, y)`: all rows in both x and y
    - `union(x, y)`: rows in either x or y
    - `setdiff(x, y)`: rows in x, but not y


# `tidyr`

## Sample data

```{r, include=TRUE, echo=TRUE, size="scriptsize", eval=TRUE, warning=FALSE}
library(tidyr)

stocks <- data.frame(
    time = as.Date('2009-01-01') + 0:9,
    X = rnorm(10, 0, 1),
    Y = rnorm(10, 0, 2),
    Z = rnorm(10, 0, 4)
)

stocks
```

## Bring columns together with `gather()`

```{r, include=TRUE, echo=TRUE, size="scriptsize", eval=TRUE, warning=FALSE}
stocksm <- stocks %>% gather(stock, price, -time)
stocksm
```


## Split a column with `spread()`

```{r, include=TRUE, echo=TRUE, size="scriptsize", eval=TRUE, warning=FALSE}
stocksm %>% spread(stock, price)
stocksm %>% spread(time, price)
```


## `spread()` and `gather()` are complements

```{r, include=TRUE, echo=TRUE, size="scriptsize", eval=TRUE, warning=FALSE}
df <- data.frame(x = c("a", "b"), y = c(3, 4), z = c(5, 6))
df
df %>% spread(x, y) %>% gather(x, y, a:b, na.rm = TRUE)
```

## There's much more

- As usual, read the [vignette](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) on the CRAN page


